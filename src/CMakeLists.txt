set(SRC
	stdlib/f08estop.f90
	stdlib/stdlib_ascii.f90
	stdlib/stdlib_error.f90
	stdlib/stdlib_io_npy.f90
	stdlib/stdlib_io_npy_load.f90
	stdlib/stdlib_io_npy_save.f90
	stdlib/stdlib_kinds.f90
	stdlib/stdlib_optval.f90
	stdlib/stdlib_strings.f90	
	stdlib/stdlib_strings_to_string.f90	
	stdlib/stdlib_string_type.f90	
	stdlib/stdlib_string_type_constructor.f90	
	precision.F90
	interp.f90
	fvm_bardow.F90
	periodic_dugks.F90
	periodic_lbm.f90
	collision_bgk.F90
	collision_bgk_improved.f90
	collision_trt.F90
	collision_regularized.F90
	vorticity.f90
	output/gnuplot.F90
	output/npy.f90
	output/vtk.F90
	benchmarks/barotropic_vortex_case.F90
	benchmarks/shear_layer.f90
	benchmarks/taylor_green.f90
	)

# Process C++ files independently
set(CXX_SRC
	output/vtk_polydata.cc)

add_library(${PROJECT_NAME}_cxx ${CXX_SRC})

add_library(${PROJECT_NAME} ${SRC})

target_link_libraries(${PROJECT_NAME} PUBLIC ${PROJECT_NAME}_cxx)

if(OpenMP_Fortran_FOUND)
	target_link_libraries(${PROJECT_NAME} PUBLIC OpenMP::OpenMP_Fortran)
endif()


set(LIB_MOD_DIR ${CMAKE_CURRENT_BINARY_DIR}/mod_files/)
# We need the module directory before we finish the configure stage since the
# build interface might resolve before the module directory is generated by CMake
if(NOT EXISTS "${LIB_MOD_DIR}")
  make_directory("${LIB_MOD_DIR}")
endif()

set_target_properties(${PROJECT_NAME} PROPERTIES
    Fortran_MODULE_DIRECTORY ${LIB_MOD_DIR})
target_include_directories(${PROJECT_NAME} PUBLIC
    $<BUILD_INTERFACE:${LIB_MOD_DIR}>
    $<INSTALL_INTERFACE:${CMAKE_INSTALL_MODULEDIR}>
)